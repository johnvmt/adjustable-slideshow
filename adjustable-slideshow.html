<template is="adjustable-slideshow">
	<style>
		:host {
			display: block;
			height: 100%;
			width: 100%;
		}

		a img {
			width: 100%;
			height: 100%;
			-webkit-filter: invert(100%) opacity(75%);
			filter: invert(100%) opacity(75%);
		}

		#controls {
			display: none;
		}
	</style>
	<link rel="stylesheet" type="text/css" href="bower_components/animate.css/animate.min.css">

	<div id="container" style="width: 100%; height: 100%; background-color: #333333; overflow: hidden">
		<div id="controls" style="z-index: 1; position: absolute; top: 0; left: 0;">
		</div>
	</div>
</template>

<script>
	(function() {
		let componentDoc =  (document._currentScript || document.currentScript).ownerDocument;
		let componentDir = componentDoc.baseURI.substring(0, componentDoc.baseURI.lastIndexOf('/'));
		let componentFile = componentDoc.baseURI.substring(componentDoc.baseURI.lastIndexOf('/') + 1);
		let componentName = componentFile.substring(0, componentFile.lastIndexOf('.'));

		class AdjustableSlideshow extends HTMLElement {

			constructor() {
				super();

				let thisElem = this;

				// Gets content from <template>
				let shadow = this.attachShadow({mode: 'open'});
				let template = componentDoc.querySelector('template[is=adjustable-slideshow]').content;
				shadow.appendChild(document.importNode(template, true));

				thisElem.slides = [];

				this._elements = {
				}
			}

			connectedCallback() {
				let thisElem = this;
				let elementAttributesDefault = {};

				// get and merge params
				thisElem.elementAttributes = thisElem._objectExtend(elementAttributesDefault, thisElem.getAttributes());

				thisElem._elements.contentContainer = thisElem.shadowRoot.querySelector('#container')

				// Clone children

				let childElems = thisElem._objectExtend({}, thisElem.children);

				objectForEach(childElems, function(child) {
					if(child['localName'] == "div")// TODO change to slide
						thisElem.addSlide(child);
				});

				// Add the actions to the buttons (clicking play button plays the video, etc.)
				thisElem.addButtonsEventListeners(thisElem._elements.contentContainer, 'data-transport');

				// Set up observer on children and character data. Remove if not needed
				thisElem.addObservers();

			}

			removeSlideIndex(slideIndex) {
				let thisElem = this;
				thisElem.removeObservers();
				if(typeof thisElem.slides[slideIndex] == 'object') {

					let slideRemove = thisElem.slides[slideIndex];
					if(typeof slideRemove.originalElement == 'object' && slideRemove.originalElement.parentNode == thisElem._elements.contentContainer)
						thisElem._elements.contentContainer.removeChild(slideRemove.originalElement);

					if(typeof slideRemove.originalElement == 'object' && slideRemove.cloneElement.parentNode == thisElem)
						thisElem.removeChild(slideRemove.cloneElement);

					thisElem.slides.splice(slideIndex, 1);
				}
				thisElem.addObservers();
			};

			removeSlide(slideDomNode) {
				for(let slideIndex = 0; slideIndex < this.slides.length; slideIndex++) {
					if(this.slides[slideIndex].originalElement == slideDomNode || this.slides[slideIndex].cloneElement == slideDomNode)
						this.removeSlideIndex(slideIndex);
				}
			};

			addSlide(slideDomNode, order) {

				let childClone = slideDomNode.cloneNode(true);
				this.slides.push({
					originalElement: slideDomNode,
					cloneElement: childClone
				});

				slideDomNode.style.position = "absolute";
				slideDomNode.style.top = "0";
				slideDomNode.style.left = "0";
				slideDomNode.style.width = "100%";
				slideDomNode.style.height = "100%";

				// TODO determine Z-Index
				// If z-index is set, maintain it
				// Otherwise, make the z-index 1 less than node it come after and increase all z-indices <=
				// First slide should have highest Z-index
				// Subsequent slides should have lower z-index

				let minSlideIndex = null;
				this.slides.forEach(function(slide) {
					if(minSlideIndex == null || slide.originalElement.style.zIndex < minSlideIndex)
						minSlideIndex = slide.originalElement.style.zIndex;
					slide.originalElement.style.zIndex++;
				});

				// Put this slide on the bottom
				slideDomNode.style.zIndex = (minSlideIndex == null) ? 1 : minSlideIndex; //this.slides.length;

				this.removeObservers(); // Remove observers while adding nodes internally
				// TODO add option to insert after or before
				this._elements.contentContainer.appendChild(slideDomNode);
				this.appendChild(childClone);
				this.addObservers(); // Add the observers once the operation is complete
			};

			// TODO rename
			makeTopIndex(slideIndex, mirrorTag) {
				let slideDomNode = this.slideIndexDomNode(slideIndex);
				this.makeTop(slideDomNode, mirrorTag);
			};

			// Get index of slide with dom node
			slideDomNodeIndex(slideDomNode) {
				let childrenArray = Array.prototype.slice.call(this.children); // convert to array

				let slideIndex = -1;
				for(let index = 0; index < childrenArray.length; index++) {
					if(childrenArray[index].localName == 'div') // TODO change to 'slide'
						slideIndex++;
					if(slideDomNode == childrenArray[index])
						return slideIndex;
				}

			};

			// Get dom node of slide with index
			slideIndexDomNode(slideIndex) {
				let childrenArray = Array.prototype.slice.call(this.children); // convert to array

				// Filter to only include slides
				childrenArray = childrenArray.filter(function(childNode) {
					return childNode.localName == 'div';  // TODO change to 'slide'
				});

				return childrenArray[slideIndex];
			};

			makeTop(slideDomNode, mirrorTag) {
				// input can be original slide node or slide's clone

				let slidesSorted = this.slides.slice(0); // clone the array

				// Sort by Z-Index
				slidesSorted.sort(function(slide1, slide2) {
					let value1 = slide1.originalElement.style.zIndex;
					let value2 = slide2.originalElement.style.zIndex;
					if(value1 < value2)
						return -1;
					else if(value2 > value1)
						return 1;
					else
						return 0;
				});

				// Find the target slide
				let targetSlideIndex = null;
				slidesSorted.forEach(function(slide, slideIndex) {
					if(slide.originalElement == slideDomNode || slide.cloneElement == slideDomNode)
						targetSlideIndex = slideIndex;
				});

				let targetSlide = slidesSorted[targetSlideIndex];
				slidesSorted.splice(targetSlideIndex, 1); // remove target from the array
				slidesSorted.push(targetSlide); // append it to the end

				// Set each slide's z-index
				slidesSorted.forEach(function(slide, slideIndex) {
					slide.originalElement.style.zIndex = slideIndex;
				});

				//addClass(targetSlide.originalElement, 'animated');
				//addClass(targetSlide.originalElement, 'fadeIn');

				let slideIndex = this.slideDomNodeIndex(targetSlide.cloneElement);

				this.emitMirror(mirrorTag, 'makeTopIndex', [slideIndex]);
			};

			addButtonsEventListeners(contentContainer, buttonSelector) {
				let events = ['click'];

				let thisElement = this;

				// Get the elements we'll add the handlers to
				let eventElements = contentContainer.querySelectorAll('[' + buttonSelector + ']');

				for (let resultIndex = 0; resultIndex < eventElements.length; resultIndex++) {
					// Create a closure for elementFunction
					(function(){
						// Get the function this element is supposed to trigger
						let elementFunction = eventElements[resultIndex].getAttribute(buttonSelector);

						// Check the function actually exists
						// TODO: add argument options?
						if(typeof thisElement[elementFunction] === 'function') {
							let callback = function() {
								thisElement[elementFunction]();
							};

							addElementEventListener(eventElements[resultIndex], events, callback);
						}
						else
							console.error(elementFunction, "not found");
					})();
				}
			};

			emitMirror(mirrorTag, functionName, functionArgs) {
				if(typeof functionArgs == 'undefined')
					functionArgs = [];

				let emitMirrorDetail = {function: functionName, arguments: Array.prototype.slice.call(functionArgs)};
				if(typeof mirrorTag != 'undefined')
					emitMirrorDetail.tag = mirrorTag;

				let emitEvent = document.createEvent('CustomEvent');
				emitEvent.initCustomEvent('mirror', true, true, emitMirrorDetail);
				this.dispatchEvent(emitEvent);
			};

			addObservers() {
				let thisElem = this;
				thisElem.removeObservers(); // Disconnect any observers already added
				thisElem.observer = thisElem._addElementObserver(thisElem, ['childList', 'characterData', 'subtree', 'attributeOldValue'], function(mutationRecords) {
					mutationRecords.forEach(function(mutationRecord) {
						// Ignore changes to thisElem attributes, as these are handled by attributeChangedCallback
						if(mutationRecord.target !== thisElem || mutationRecord.type !== 'attributes')
							thisElem.childMutatedCallback(thisElem, mutationRecord);
					});
				});

				thisElem.contentObserver = thisElem._addElementObserver(thisElem._elements.contentContainer, ['childList', 'characterData', 'subtree', 'attributeOldValue'], function(mutationRecords) {
					mutationRecords.forEach(function(mutationRecord) {
						// Ignore changes to thisElem attributes, as these are handled by attributeChangedCallback
						if(mutationRecord.target !== thisElem._elements.contentContainer || mutationRecord.type !== 'attributes')
							thisElem.childMutatedCallback(thisElem._elements.contentContainer, mutationRecord);
					});
				});
			};

			removeObservers() {
				if(typeof this.observer != 'undefined')
					this.observer.disconnect();

				if(typeof this.contentObserver != 'undefined')
					this.contentObserver.disconnect();
			};

			// Called when an attribute of this element is added, removed, or updated
			attributeChangedCallback(attr, oldVal, newVal) {
				//console.log("attributeChangedCallback");
			};

			// Called when an attribute in a child element is changed; uses child observer
			childAttributeChangedCallback(target, attr, oldVal, newVal) {
				//console.log("childAttributeChangedCallback")
			};

			// Called when a child element is added; uses child observer
			childAddedCallback(child) {
				if(child.localName == 'div') // TODO replace with slide
					this.addSlide(child);
			};

			// Called when a child element is removed; uses child observer
			childRemovedCallback(child) {
				if(child.localName == 'div') // TODO replace with slide
					this.removeSlide(child);
			};

			_moveCloneChildren(sourceNode, sinkNode) {
				while(sinkNode.hasChildNodes()) {
					sinkNode.removeChild(sinkNode.children[0]);
				}

				while(sourceNode.hasChildNodes()) {
					sinkNode.appendChild(sourceNode.children[sourceNode.children.length - 1]);
				}

				for(let ctr = sinkNode.children.length - 1; ctr >= 0; ctr--) {
					let cloneChild = sinkNode.children[ctr].cloneNode(true);
					sourceNode.appendChild(cloneChild);
				}

			};

			// Called when a child element (child) is added to a child of this (target); uses child observer
			descendantAddedCallback(target, child) {
				let thisElem = this;
				thisElem.removeObservers();
				this.slides.forEach(function(slide) {
					if(slide.originalElement == target) // Modified the original (inside)
						thisElem._moveCloneChildren(slide.originalElement, slide.cloneElement);
					else if(slide.cloneElement == target) // Modified the clone (outside)
						thisElem._moveCloneChildren(slide.cloneElement, slide.originalElement);
				});
				thisElem.addObservers();
			};

			// alled when a descendant element (child) is removed from a child of this (target); uses child observer
			descendantRemovedCallback(target, child) {
				/*
				var thisElem = this;
				thisElem.removeObservers();
				this.slides.forEach(function(slide) {
					if(slide.originalElement == target) // Modified the original (inside)
						thisElem._moveCloneChildren(slide.originalElement, slide.cloneElement);
					else if(slide.cloneElement == target) // Modified the clone (outside)
						thisElem._moveCloneChildren(slide.cloneElement, slide.originalElement);
				});
				thisElem.addObservers();
				*/
			};

			// Called when element's innerHtml is changed; uses child observer
			characterDataChangedCallback(newData) {
				console.log("characterDataChangedCallback")
			};

			// Called when a child element is changed; uses child observer
			childMutatedCallback(targetNode, mutationRecord) {
				switch(mutationRecord.type) {
					case "childList":
						if(mutationRecord.target === targetNode) { // Direct descendant
							for(let ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
								this.childAddedCallback(mutationRecord.addedNodes[ctr]);
							for(let ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
								this.childRemovedCallback(mutationRecord.removedNodes[ctr]);
						}
						else {
							for(let ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
								this.descendantAddedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
							for(let ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
								this.descendantRemovedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
						}
						break;
					case "attributes":
						this.childAttributeChangedCallback(mutationRecord.target, mutationRecord.attributeName, mutationRecord.oldValue, this.getAttribute(mutationRecord.attributeName, mutationRecord.target));
						break;
					case "characterData":
						this.characterDataChangedCallback(mutationRecord.target.data);
						break;
				}
			};

			// Get all attributes of element
			getAttributes(target) {
				if(typeof target === 'undefined')
					target = this;

				let attributes = {};
				for(let ctr = 0; ctr < target.attributes.length; ctr++) {
					attributes[target.attributes[ctr].nodeName] = target.attributes[ctr].nodeValue;
				}
				return attributes;
			};

			/* Utility Functions */
			_hasClass(el, className) {
				if (el.classList)
					return el.classList.contains(className);
				else
					return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
			}

			_addClass(el, className) {
				if (el.classList)
					el.classList.add(className);
				else if (!hasClass(el, className)) el.className += " " + className
			}

			_removeClass(el, className) {
				if (el.classList)
					el.classList.remove(className);
				else if (hasClass(el, className)) {
					var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
					el.className=el.className.replace(reg, ' ')
				}
			}

			// Add observers to an element
			_addElementObserver(element, mutations, listener) {
				// possible mutations: 	attributes, childList, characterData
				let observer = new MutationObserver(listener);

				if(mutations.length > 0) {
					let observerConfig = {};
					for(let mutationIndex = 0; mutationIndex < mutations.length; mutationIndex++) {
						observerConfig[mutations[mutationIndex]] = true;
					}
					observer.observe(element, observerConfig);
				}

				return observer;
				// Returned observer can be removed with observer.disconnect()
			}

			// Add event triggers for an element
			_addElementEventListener(element, events, listener) {
				// if string (single event) passed, convert to Array
				if(!Array.isArray(events))
					events = [events];

				for(let eventIndex = 0; eventIndex < events.length; eventIndex++) {
					element.addEventListener(events[eventIndex], listener);
				}
			}

			// Return sum of all objects passed as new object, with later arguments overwriting
			_objectExtend() {
				let merged = {};
				objectForEach(arguments, function(argument) {
					for (let attrname in argument) {
						if(argument.hasOwnProperty(attrname))
							merged[attrname] = argument[attrname];
					}
				});
				return merged;
			}

			// Iterate over object properties
			_objectForEach(object, callback) {
				// run function on each property (child) of object
				let property;
				for(property in object) { // pull keys before looping through?
					if (object.hasOwnProperty(property))
						callback(object[property], property, object);
				}
			}

			// Filter object properties
			_objectFilter(object, filter) {
				// filter object properties (children) using filter function
				// similar to array filter function
				let result = {};
				this.objectForEach(object, function(child, property, parent) {
					if(filter(child, property, parent))
						result[property] = child;
				});
				return result;
			}

			// Returns property of object whose value matches search value
			_objectPropertyOf(object, searchValue) {
				let property;
				for(property in object) {
					if(object.hasOwnProperty(property) && object[property] == searchValue)
						return property;
				}
				return undefined;
			}

		}

		customElements.define('adjustable-slideshow', AdjustableSlideshow);
	})();
</script>